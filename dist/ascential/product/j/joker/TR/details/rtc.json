{
  "interactions": [
    {
      "constructor": "CodeAction",
      "code": "module.exports = async function (extractorInputs) {\n  const log = console.log;\n  console.log = function (...args) {\n    log.apply(console, [new Date().toISOString()].concat(args));\n  };\n\n  const length = (results) => results.reduce((acc, { group }) => acc + (Array.isArray(group) ? group.length : 0), 0);\n  const makeProxy = (name, obj) => {\n    let calls = -1;\n    return new Proxy(obj,\n      {\n        get (target, propKey) {\n          const origMethod = target[propKey];\n          if (propKey === 'retryContext') {\n            const idx = calls++;\n            return target[propKey];\n          }\n          if (!origMethod) {\n            throw new Error(`No such property: ${String(propKey)}`);\n          }\n          if (propKey === 'counter') {\n            return new Proxy(target[propKey], {\n              get (t, pk) {\n                const idx = calls++;\n                const oM = t[pk];\n                return async (...args) => {\n                  console.log(`[${name}:${idx}] ${name}.counter.${pk.toString()}(${args.map((o) => typeof o === 'function' ? o.toString() : JSON.stringify(o)).join(', ')})`);\n                  const value = await oM.apply(obj, args);\n                  return value;\n                };\n              },\n            });\n          }\n          return async (...args) => {\n            const idx = calls++;\n            console.log(`[${name}:${idx}] ${name}.${propKey.toString()}(${args.map((o) => typeof o === 'function' ? o.toString() : JSON.stringify(o)).join(', ')})`);\n            const value = await origMethod.apply(obj, args);\n            console.log(`[${name}:${idx}]`, propKey === 'extract' ? length(value) + ' results' : value);\n            return value;\n          };\n        },\n      },\n    );\n  };\n\n  class CodeActionContext {\n    // private cookiesToRemove: ICookieDef[] = [];\n    // private cookiesToSet: ICookie = [];\n    constructor (context, extractions, input) {\n      this.context = context;\n      this.extractions = extractions;\n      this.input = input;\n      this.useRelayProxy = true;\n      this._data = [];\n      this.firstRequestTimeout = 20000;\n      this.antiFingerprint = true;\n      this.downloadLimit = 150e6;\n      this.downloadTimeout = 240e3;\n      this.downloadRetries = 3;\n      // support old misspelled function name for backward compatibility\n      this.waitForMutuation = this.waitForMutation;\n      this.setViewPort({\n        width: 2048,\n        height: 1235,\n      });\n    }\n\n    get counter () {\n      return {\n        set: (key, value) => this.context.counter.set(key, value),\n        get: (key) => this.context.counter.get(key),\n        delete: (key) => this.context.counter.delete(key),\n        increment: (key, incr) => this.context.counter.increment(key, incr),\n      };\n    }\n\n    async addToDom (id, data, options) {\n      const inputs = Object.assign({ id, data }, options);\n      await this.evaluate((inputs) => {\n        const addItemToDocument = ({ id, data, parentSelector, cssClass } = inputs) => {\n          const htmlString = `<div id=\"${id}\" ${cssClass ? `class=\"${cssClass}\" ` : ''}></div>`;\n          const rootSelector = parentSelector ? document.querySelector(parentSelector) : document.body;\n          const hiddenDiv = document.querySelector(`#${id}`);\n          rootSelector.insertAdjacentHTML('beforeend', htmlString);\n          if (hiddenDiv) {\n            hiddenDiv.innerHTML = data;\n          }\n        };\n        addItemToDocument(inputs);\n      }, inputs);\n    }\n\n    captureRequests () {\n      return this.context.installAssetProxy();\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    click (selector, options) {\n      return this.context.click(selector);\n    }\n\n    checkBlocked (statusCode) {\n      return this.context.checkBlocked(statusCode);\n    }\n\n    content (opts) {\n      return this.context.getHtml(opts);\n    }\n\n    cookies (...urls) {\n      if (urls.length > 0) {\n        throw new Error('Unsupported urls');\n      }\n      return this.context.getCookies();\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    deleteCookies (...cookies) {\n      throw new Error('Method not implemented.');\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    emulateTimezone (timezoneId) {\n      throw new Error('Method not implemented.');\n    }\n\n    enableNetworkDebugger () {\n      return this.context.enableNetworkDebugger();\n    }\n\n    get retryContext () {\n      return this.context.retryContext;\n    }\n\n    async waitForMutation (selector, options) {\n      await this.evaluate(function (selector, timeout) {\n        const target = document.querySelector(selector);\n        if (!target) {\n          throw new Error('Cannot find element ' + selector);\n        }\n        return new Promise((resolve, reject) => {\n          const callback = () => {\n            try {\n              resolve();\n            } finally {\n              clearTimeout(timer);\n              ob.disconnect();\n            }\n          };\n          const timer = setTimeout(() => {\n            try {\n              reject(new Error('Timeout waiting for mutation: ' + selector));\n            } finally {\n              ob.disconnect();\n            }\n          }, timeout);\n          const ob = new MutationObserver(callback);\n          ob.observe(target, { subtree: true, childList: true });\n        });\n      }, selector, options.timeout || 10000);\n    }\n\n    evaluate (pageFunction, ...args) {\n      // TODO: why do arrow functions not work?\n      const fn = this.wrapArrowFunction(pageFunction);\n      return this.context.execute(fn, args);\n    }\n\n    evaluateInFrame (context, pageFunction, ...args) {\n      const fn = this.wrapArrowFunction(pageFunction);\n      return this.context.execute(fn, args, context);\n    }\n\n    wrapArrowFunction (pageFunction) {\n      let fn = pageFunction.toString();\n      if (/^\\s*(async\\s*)?\\(/.test(fn)) {\n        fn = `function(...args) { const f = ${pageFunction}; return f.apply(null, args); }`;\n      }\n      return fn;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    focus (selector) {\n      throw new Error('Method not implemented.');\n    }\n\n    async goto (url, options) {\n      var _a;\n      if (options === null || options === void 0 ? void 0 : options.captureRequests) {\n        await this.captureRequests();\n      }\n      const result = await this.context.goto({ url, options: this.buildOptions(options) });\n      if (((_a = options === null || options === void 0 ? void 0 : options.checkBlocked) !== null && _a !== void 0 ? _a : true) && await this.context.checkBlocked(result.code)) {\n        await this.reportBlocked(result.code, 'Blocked');\n        throw new Error('Goto url failed, status=' + result.code);\n      }\n      const response = {\n        headers: result.headers,\n        status: result.code,\n        ok: result.code >= 200 && result.code < 300,\n        url: result.url,\n      };\n      return response;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    hover (selector) {\n      throw new Error('Method not implemented.');\n    }\n\n    async reportBlocked (code, message = 'Blocked') {\n      return this.context.reportBlocked(code, message);\n    }\n\n    async reportWrongGeocoding () {\n      return this.context.raiseError('WRONG_GEO', 'Incorrect locale detected');\n    }\n\n    async saveJson (id, data) {\n      const inputs = { id, data };\n      await this.evaluate((inputs) => {\n        const addJsonToScriptTag = ({ id, data } = inputs) => {\n          let jsonScript = document.querySelector(id);\n          if (!jsonScript) {\n            jsonScript = document.createElement('script');\n            jsonScript.type = 'application/json';\n            jsonScript.id = id;\n          }\n          jsonScript.innerHTML = JSON.stringify(data);\n          document.body.append(jsonScript);\n        };\n        addJsonToScriptTag(inputs);\n      }, inputs);\n    }\n\n    async screenshot (options) {\n      if ((options === null || options === void 0 ? void 0 : options.fullPage) != null) {\n        throw new Error('fullPage not supported');\n      }\n      await this.context.screenCapture(options === null || options === void 0 ? void 0 : options.type);\n    }\n\n    searchForRequest (urlPattern, method = 'GET', pastTimestamp = 0, timeout = 60) {\n      return this.context.searchForRequest(urlPattern, method, pastTimestamp, timeout);\n    }\n\n    searchAllRequests (urlPattern, method = 'GET', pastTimestamp = 0) {\n      return this.context.searchAllRequests(urlPattern, method, pastTimestamp);\n    }\n\n    select (selector, ...values) {\n      return this.context.select(selector, values);\n    }\n\n    async setUseRelayProxy (useRelayProxy) {\n      this.useRelayProxy = useRelayProxy;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    setContent (url, html) {\n      throw new Error('Method not implemented.');\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    setCookie (...cookies) {\n      throw new Error('Method not implemented.');\n    }\n\n    async setUserAgent (ua) {\n      this.userAgent = ua;\n    }\n\n    async setBypassCSP (enabled) {\n      this.bypassCSP = enabled;\n    }\n\n    async setExtraHTTPHeaders (headers) {\n      this.extraHttpHeaders = headers;\n    }\n\n    async setJavaScriptEnabled (enabled) {\n      this.javascriptEnabled = enabled;\n    }\n\n    async setLoadImages (enabled) {\n      this.loadImages = enabled;\n    }\n\n    async setLoadAllResources (enabled) {\n      this.loadAllResources = enabled;\n    }\n\n    async setCssEnabled (enabled) {\n      this.cssEnabled = enabled;\n    }\n\n    async setBlockAds (enabled) {\n      this.blockAds = enabled;\n    }\n\n    async setViewPort (viewport) {\n      this.viewport = viewport;\n    }\n\n    async setFirstRequestTimeout (firstRequestTimeout) {\n      this.firstRequestTimeout = firstRequestTimeout;\n    }\n\n    async setAntiFingerprint (antiFingerprint) {\n      this.antiFingerprint = antiFingerprint;\n    }\n\n    async setDownloadLimit (downloadLimit) {\n      this.downloadLimit = downloadLimit;\n    }\n\n    async setDownloadTimeout (downloadTimeout) {\n      this.downloadTimeout = downloadTimeout;\n    }\n\n    async setDownloadRetries (downloadRetries) {\n      this.downloadRetries = downloadRetries;\n    }\n\n    setInputValue (selector, value) {\n      return this.context.input(selector, value);\n    }\n\n    solveCaptcha (options) {\n      return this.context.solveCaptcha(options);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    type (selector, text, options) {\n      throw new Error('Method not implemented.');\n    }\n\n    async waitForSelector (selector, options) {\n      // eslint-disable-next-line unicorn/consistent-function-scoping\n      function fn (s) {\n        return Boolean(document.querySelector(s));\n      }\n      await this.waitForFunction(fn, options, selector);\n    }\n\n    async stop () {\n      await this.evaluate(() => window.stop());\n    }\n\n    // TODO: a lot of functions currently use this for the timeout fn\n    waitForFunction (predicate, options, ...args) {\n      const timeoutAt = Date.now() + ((options === null || options === void 0 ? void 0 : options.timeout) || 10000);\n      const f = `function() { if ( Date.now() > ${timeoutAt} ) throw new Error(\"Timeout\"); const f = ${predicate.toString()}; return f.apply(null, ${JSON.stringify(args)}); }`;\n      return this.context.waitForFunction(f);\n    }\n\n    async waitForNavigation (options) {\n      const pageId = await this.context.getPageId();\n      return () => this.context.waitForNextPage(pageId, ((options === null || options === void 0 ? void 0 : options.timeout) || 30000) / 1000);\n    }\n\n    async clickAndWaitForNavigation (selector, clickOptions, navigationOptions) {\n      const factory = await this.waitForNavigation(navigationOptions);\n      await Promise.all([\n        this.click(selector, clickOptions),\n        factory(),\n      ]);\n    }\n\n    async waitForXPath (xpath, options) {\n      // eslint-disable-next-line unicorn/consistent-function-scoping\n      function fn (xp) {\n        return Boolean(document.evaluate(xp, document, null, XPathResult.ANY_UNORDERED_NODE_TYPE, null).singleNodeValue);\n      }\n      await this.waitForFunction(fn, options, xpath);\n    }\n\n    async extract (extractionConfig, mergeOptions) {\n      var _a;\n      const viewport = this.viewport;\n      const { width, height } = await this.evaluate(function () {\n        return {\n          height: document.body.scrollHeight,\n          width: document.body.scrollWidth,\n        };\n      });\n      await this.setViewPort({ width, height });\n      try {\n        const config = (await this.extractions(extractionConfig)).config;\n        if (!config) {\n          throw new Error('Cannot find extraction configuration');\n        }\n        await this.saveJson('__input', this.input);\n        const data = await this.context.extractData(config, false);\n        const url = await this.context.getURL();\n        let resultMergeOptions;\n        if (mergeOptions) {\n          resultMergeOptions = Object.assign(Object.assign({}, mergeOptions), { transform: (_a = mergeOptions.transform) === null || _a === void 0 ? void 0 : _a.toString() });\n        }\n        const result = { mergeOptions: resultMergeOptions, extractionConfig, data, url, timestamp: new Date().toISOString() };\n        const _data = this._data;\n        _data.push(result);\n        return data;\n      } finally {\n        await this.setViewPort(viewport);\n      }\n    }\n\n    async reload () {\n      await this.context.reload();\n    }\n\n    /**\n     * This is used on the server side to actually encode the data in a compatible format\n     */\n    _crawlData () {\n      return this.context.createData({ pages: this._data });\n    }\n\n    data () {\n      return this._data;\n    }\n\n    buildOptions (input) {\n      var _a, _b;\n      let headers = (input === null || input === void 0 ? void 0 : input.headers) || this.extraHttpHeaders;\n      const referer = (_a = input) === null || _a === void 0 ? void 0 : _a.referer;\n      if (referer) {\n        if (!headers) {\n          headers = {};\n        }\n        headers.referer = referer;\n      }\n      const options = {\n        user_agent: this.userAgent,\n        js_enabled: this.javascriptEnabled,\n        images_enabled: this.loadImages,\n        load_all_resources: this.loadAllResources,\n        block_ads: this.blockAds,\n        viewport: this.viewport,\n        discard_CSP_header: this.bypassCSP,\n        headers,\n        goto_timeout: ((input === null || input === void 0 ? void 0 : input.timeout) || 60000) / 1000,\n        http_method: (_b = input) === null || _b === void 0 ? void 0 : _b.method,\n        random_move_mouse: true,\n        css_enabled: this.cssEnabled,\n        first_request_timeout: ((input === null || input === void 0 ? void 0 : input.firstRequestTimeout) || this.firstRequestTimeout) / 1000,\n        anti_fingerprint: ((input === null || input === void 0 ? void 0 : input.antiFingerPrint) || this.antiFingerprint),\n        downloadLimit: ((input === null || input === void 0 ? void 0 : input.downloadLimit) || this.downloadLimit),\n        downloadRetries: ((input === null || input === void 0 ? void 0 : input.downloadRetries) || this.downloadRetries),\n        downloadTimeout: ((input === null || input === void 0 ? void 0 : input.downloadTimeout) || this.downloadTimeout),\n        antiCaptchaOptions: input === null || input === void 0 ? void 0 : input.antiCaptchaOptions,\n      };\n      if (!this.useRelayProxy) {\n        options.proxy = options.proxy || {};\n        options.proxy.use_relay_proxy = false;\n      }\n      const waitUntil = input === null || input === void 0 ? void 0 : input.waitUntil;\n      if (waitUntil == null || waitUntil === 'load') {\n        options.load_timeout = 0;\n        options.max_new_request_gap = 0;\n      } else if (waitUntil === 'networkidle0') {\n        options.load_timeout = 10;\n        options.max_new_request_gap = 500;\n      } else {\n        throw new Error('Unsupported wait:' + waitUntil);\n      }\n      return options;\n    }\n  }\n  const modules = {};\n  const context = new CodeActionContext(extractorContext, (name) => modules['extraction:' + name], extractorInputs);\n  const proxy = makeProxy('context', context);\n  if (typeof global !== 'undefined') global.context = context;\n  modules['action:product/details'] = (inputs, parameters) => {\n    const dependencies = {\n      execute: modules['action:product/details/execute'],\n      extract: modules['action:product/details/extract'],\n    };\n    const fn = async function implementation (inputs, parameters, context, dependencies) {\n      const { URL, RPC, SKU, UPC, storeID } = inputs;\n      const { execute, extract } = dependencies;\n      const url = URL;\n      const id = RPC || SKU || UPC || inputs.id;\n      const zipcode = inputs.zipcode || parameters.zipcode;\n      const storeId = inputs.storeId || storeID || parameters.storeId;\n\n      const newInput = { ...inputs, storeId, zipcode, url, id };\n\n      const resultsReturned = await execute(newInput);\n      if (!resultsReturned) {\n        console.log('No results were returned');\n        return;\n      }\n\n      await extract(newInput);\n    };\n\n    const params = { country: 'TR', store: 'joker', domain: 'joker.com.tr', zipcode: '' } || parameters;\n    return fn(inputs, params, proxy, dependencies);\n  };\n  modules['action:product/details/execute'] = (inputs, parameters) => {\n    const dependencies = {\n      goto: modules['action:navigation/goto'],\n      createUrl: modules['action:product/details/createUrl'],\n    };\n    const fn = async (inputs, { loadedSelector, noResultsXPath }, context, dependencies) => {\n      const { url, id } = inputs;\n      let builtUrl;\n      if (!url) {\n        if (!id) throw new Error('No id provided');\n        else builtUrl = await dependencies.createUrl(inputs);\n        if (!builtUrl) return false; // graceful exit when not able to create a url\n      }\n\n      await dependencies.goto({ ...inputs, url: builtUrl || url });\n\n      if (loadedSelector) {\n        await context.waitForFunction(\n          (selector, xpath) => {\n            return !!(document.querySelector(selector) || document.evaluate(xpath, document, null, XPathResult.BOOLEAN_TYPE, null).booleanValue);\n          },\n          { timeout: 10000 },\n          loadedSelector,\n          noResultsXPath,\n        );\n      }\n      return await context.evaluate((xpath) => !document.evaluate(xpath, document, null, XPathResult.BOOLEAN_TYPE, null).booleanValue, noResultsXPath);\n    };\n\n    const params = { country: 'TR', store: 'joker', domain: 'joker.com.tr', loadedSelector: 'body', noResultsXPath: '//div[contains(@class,\"not-found-content\")]', zipcode: '' } || parameters;\n    return fn(inputs, params, proxy, dependencies);\n  };\n  modules['action:navigation/goto'] = (inputs, parameters) => {\n    const dependencies = {\n      setZipCode: modules['action:navigation/goto/setZipCode'],\n    };\n    const fn = async (inputs, parameters, context, dependencies) => {\n      const { timeout = 10000 } = parameters;\n      const { url, zipcode, storeId } = inputs;\n      await context.goto(url, { timeout, waitUntil: 'load', checkBlocked: true, captureRequests: true });\n\n      // patch for synchronicity issue between json decoring and goto result\n      if (url.split('[!opt!]')[1] && url.split('[!opt!]')[1].includes('\"type\":\"json\"')) {\n        console.log('Wait for handling synchronicity issue');\n        await new Promise((resolve) => setTimeout(resolve, 8000));\n      }\n\n      console.log(`zipcode: ${zipcode}`);\n      if (zipcode || storeId) {\n        await dependencies.setZipCode(inputs);\n      }\n    };\n\n    const params = { domain: 'joker.com.tr', timeout: null, jsonToTable: null, country: 'TR', store: 'joker', zipcode: '' } || parameters;\n    return fn(inputs, params, proxy, dependencies);\n  };\n  modules['action:navigation/goto/setZipCode'] = (inputs, parameters) => {\n    const dependencies = {\n\n    };\n    const fn = async function implementation (\n      inputs,\n      parameters,\n      context,\n      dependencies,\n    ) {\n      // const { url, zipcode } = inputs;\n      // const { country, domain, store } = parameters;\n\n      // TODO: add your impl - must be self contained (no require/import/external functions)\n    };\n\n    const params = { country: 'TR', domain: 'joker.com.tr', store: 'joker', zipcode: '' } || parameters;\n    return fn(inputs, params, proxy, dependencies);\n  };\n  modules['action:product/details/createUrl'] = (inputs, parameters) => {\n    const dependencies = {\n\n    };\n    const fn = async function implementation (\n      inputs,\n      parameters,\n      context,\n      dependencies,\n    ) {\n      const { id } = inputs;\n      const { domain, prefix, suffix } = parameters;\n\n      if (parameters.url) {\n        const url = parameters.url.replace('{id}', encodeURIComponent(id));\n        return url;\n      }\n      let gotoUrl = `https://${domain}`;\n      if (prefix) {\n        gotoUrl += `/${prefix}`;\n      }\n      gotoUrl += `/${id}`;\n      if (suffix) {\n        gotoUrl += `/${suffix}`;\n      }\n      return gotoUrl;\n    };\n\n    const params = { domain: 'joker.com.tr', prefix: null, url: 'https://www.joker.com.tr/urun/{id}', country: 'TR', store: 'joker', zipcode: '' } || parameters;\n    return fn(inputs, params, proxy, dependencies);\n  };\n  modules['action:product/details/extract'] = (inputs, parameters) => {\n    const dependencies = {\n      productDetails: 'product/details/stores/j/joker/TR/extract',\n    };\n    const fn = async function implementation (\n      inputs,\n      parameters,\n      context,\n      dependencies,\n    ) {\n      const { transform } = parameters;\n      const { productDetails } = dependencies;\n      return await context.extract(productDetails, { transform });\n    };\n\n    const params = {\n      country: 'TR',\n      store: 'joker',\n      transform: (data, context) => {\n      // Default transform function\n        const clean = (text) =>\n          text\n            .toString()\n            .replace(/\\r\\n|\\r|\\n/g, ' ')\n            .replace(/&amp;nbsp;/g, ' ')\n            .replace(/&amp;#160/g, ' ')\n            .replace(/\\u00A0/g, ' ')\n            .replace(/\\s{2,}/g, ' ')\n            .replace(/\"\\s{1,}/g, '\"')\n            .replace(/\\s{1,}\"/g, '\"')\n            .replace(/^ +| +$|( )+/g, ' ')\n          // eslint-disable-next-line no-control-regex\n            .replace(/[\\x00-\\x1F]/g, '')\n            .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, ' ');\n        data.forEach((obj) =>\n          obj.group.forEach((row) =>\n            Object.keys(row).forEach((header) =>\n              row[header].forEach((el) => {\n                el.text = clean(el.text);\n              }),\n            ),\n          ),\n        );\n\n        for (const { group } of data) {\n          for (const row of group) {\n            try {\n              var product;\n              var regEx;\n              var regexMatch;\n              var productDetails;\n              console.log('CodeTrade');\n              console.log(row);\n\n              if (row.aggregateRating) {\n                product = row.aggregateRating[0].raw;\n                // regEx = /\\(([^)]+)\\)/;\n                // regexMatch = regEx.exec(product);\n\n                productDetails = JSON.parse(product);\n                // console.log(\"productDetails coDE tRADE\");\n                // console.log(productDetails);\n                row.aggregateRating = [\n                  { text: productDetails.aggregateRating.ratingValue },\n                ];\n              }\n              if (row.ratingCount) {\n                var product = row.ratingCount[0].text;\n                // console.log(product);\n                var processProduct = JSON.parse(product);\n                console.log(processProduct.aggregateRating.ratingCount);\n                row.ratingCount = [\n                  { text: processProduct.aggregateRating.ratingCount },\n                ];\n\n                //   //regEx = /\\(([^)]+)\\)/;\n                //   //regexMatch = regEx.exec(product);\n\n              //   productDetails = JSON.parse(product);\n              //   console.log(\"productDetails coDE tRADE\");\n              //   console.log(productDetails);\n              //   row.ratingCount = [\n              //     { text: productDetails.ratingCount },\n              //   ];\n              }\n              if (row.availabilityText) {\n                row.availabilityText = [\n                  {\n                    text:\n                row.availabilityText[0].text === 'true'\n                  ? 'In Stock'\n                  : 'Out Of Stock',\n                  },\n                ];\n              }\n\n              // if (row.nameExtended) {\n              //   product = row.brandText[0].text;\n              //   regEx = /\\(([^)]+)\\)/;\n              //   regexMatch = regEx.exec(product);\n\n              //   productDetails = JSON.parse(regexMatch[1]);\n              //   if (\n              //     productDetails.name.includes(productDetails.brand)\n              //   ) {\n              //     row.nameExtended = [{ text: productDetails.name }];\n              //   } else {\n              //     row.nameExtended = [\n              //       {\n              //         text: `${productDetails.brand} ${productDetails.name}`,\n              //       },\n              //     ];\n              //   }\n              // }\n              // if(row.gitn8){\n              //   product = row.gitn8[0].text;\n              //   regEx = /\\(([^)]+)\\)/;\n              //   regexMatch = regEx.exec(product);\n\n            //   productDetails = JSON.parse(regexMatch[1]);\n            //   row.gitn8 = [\n            //     { text: productDetails.gitn8 },\n            //   ];\n            // }\n            } catch (exception) {\n              console.log('Error in transform', exception);\n            }\n          }\n        }\n        return data;\n      },\n      domain: 'joker.com.tr',\n      zipcode: '',\n    } || parameters;\n    return fn(inputs, params, proxy, dependencies);\n  };\n  modules['extraction:product/details/stores/j/joker/TR/extract'] = {\n    id: 'product/details/stores/j/joker/TR/extract',\n    config: {\n      singleRecord: false,\n      regionsSelector: null,\n      recordSelector: null,\n      recordXPath: null,\n      fields: [\n        {\n          id: 'dd812847-0f10-5bfb-8b2b-036c2d759958',\n          name: 'image',\n          xpath: '//*[@id=\"jMain\"]//div[@class=\"magnify\"]/img/@src',\n          singleValue: true,\n          description: 'URL of the main product image',\n          type: 'TEXT',\n        },\n        {\n          id: '39c34f83-8e77-55fa-8550-47714465578a',\n          name: 'imageAlt',\n          xpath: \"//div[contains(@class,'product-detail-content')]//div[contains(@class,'product-detail-content')]\",\n          singleValue: true,\n          description: 'Alt text of the main product image',\n          type: 'TEXT',\n        },\n        {\n          id: '490d79c3-2364-5bc2-840d-85ba7ac85258',\n          name: 'alternateImages',\n          xpath: \"//*[@id=\\\"jMain\\\"]//div[contains(@class, 'owl-thumbs mobile-hidden')]/button[position()>1]/img/@src\",\n          singleValue: false,\n          description: 'Other product images (not in manufacturer description)',\n          type: 'TEXT',\n        },\n        {\n          id: '9f4fc150-381e-5579-9b02-be0986d8ff5c',\n          name: 'category',\n          xpath: '//*[@id=\"jMain\"]/div/nav/ol/li[contains(@class,\"active\")]',\n          singleValue: false,\n          description: 'The categories (e.g. from breadcrumbs)',\n          type: 'TEXT',\n        },\n        {\n          id: 'a8d2d517-fded-5e45-a8c7-50ef5df05601',\n          name: 'listPrice',\n          xpath: \"//p[contains(@class,'discount-price price')]\",\n          singleValue: true,\n          description: 'The stated undiscounted price for the product',\n          type: 'TEXT',\n        },\n        {\n          id: 'ed9613b9-4312-5eda-b90b-e91ffe35429d',\n          name: 'price',\n          xpath: '//*[@id=\"addToBasketForm\"]/div/div[3]/div[1]/div[2]/p',\n          singleValue: true,\n          description: 'The offered price for the selected product variant - if a user clicks add to basket this is the price they would be charged',\n          type: 'TEXT',\n        },\n        {\n          id: '7e4e9498-6ab8-5012-8490-5f93306d638b',\n          name: 'availabilityText',\n          xpath: 'boolean(//*[@id=\"addToBasketForm\"]/div/div[3]/div[3]/a[1])',\n          singleValue: true,\n          description: 'Availability as described on page for the selected variant. If there is no availability but the product can be added to cart, this field should be \"In Stock\"',\n          regExp: '(.+)',\n          regExpReplace: 'In Stock',\n          defaultValue: 'Out of Stock',\n          type: 'TEXT',\n        },\n        {\n          id: 'd70cf327-f27b-50d5-a8fc-beced67b906c',\n          name: 'description',\n          xpath: '//*[@id=\"tab01\"]/section/div[1]/p[1]',\n          singleValue: false,\n          description: 'Product description supplied by website - may be concatenanted from multiple places; specifically not the manufacturer description',\n          type: 'TEXT',\n        },\n        {\n          id: 'a7ec14a4-3530-5987-8448-74f981f15cec',\n          name: 'priceCurrency',\n          singleValue: true,\n          xpath: '//*[@id=\"addToBasketForm\"]/div/div[3]/div[1]/div[2]/p/span[2]',\n          regExp: '^[\\\\s\\\\S]{0,2}',\n          type: 'TEXT',\n        },\n        {\n          id: '2d446c24-f2ac-523b-85ef-146d158f6904',\n          name: 'brandText',\n          xpath: \"//div[contains(@class,'product-detail-table')]//td[last()]\",\n          singleValue: true,\n          description: 'Product brand shown - this may actually NOT be just a brand name, e.g. \"Visit the Gillette Store\"',\n          type: 'TEXT',\n        },\n        {\n          id: '4b17ccb0-3fd2-518a-914e-13e112ea0ef0',\n          name: 'manufacturer',\n          xpath: \"//div[contains(@class,'product-detail-table')]//tr[last()]//td[last()]\",\n          singleValue: true,\n          description: 'Product manufacturer',\n          type: 'TEXT',\n        },\n        {\n          id: '8295f567-f653-5803-8ff9-876234334079',\n          name: 'quantity',\n          xpath: 'count(//*[@id=\"product-quantity\"])',\n          singleValue: true,\n          description: 'Quantity as described on the page',\n          regExp: '(?:\\\\s?([\\\\d\\\\.]+\\\\s?)([bB]ar[s]?|[cC]ount|[cC]t|[fF][lL][\\\\.]?\\\\s?[oO][zZ][\\\\.]?|FO|[mM][lL]|[oO][zZ][\\\\.]?|pc|[pP]int|[pP]ops|qt|[wW]ipe[s]?).?)$|(?:\\\\s?([\\\\d\\\\.]+\\\\s?)([bB]ar[s]?|[cC]ount|[cC]|[fF][lL][\\\\.]?\\\\s?[oO][zZ][\\\\.]?|FO|[mM][lL]|[oO][zZ][\\\\.]?|pc|[pP]int|[pP]ops|qt|[wW]ipe[s]?).?\\\\s?[\\\\&\\\\-\\\\w\\\\s]+)$',\n          regExpReplace: '$1$2$3$4',\n          type: 'TEXT',\n        },\n        {\n          id: '868e72ee-c11d-5025-a764-f3d508a1a792',\n          name: 'weightNet',\n          xpath: '//*[@id=\"tab01\"]/section/div[1]/p[14]/font/font',\n          singleValue: true,\n          description: 'Net weight as described on the page',\n          type: 'TEXT',\n        },\n        {\n          id: 'cf8cec6b-fc88-5270-aca6-d5eb60d40f4e',\n          name: 'sku',\n          singleValue: true,\n          xpath: \"//span[contains(@id,'sku')]\",\n          description: 'The store-specific product identifier',\n          type: 'TEXT',\n        },\n        {\n          id: '60fe2efb-5db3-5d5a-876a-2fdc5c252185',\n          name: 'gtin',\n          xpath: '//*[@id=\"barcode\"]/font/font',\n          singleValue: true,\n          description: 'GTIN code (includes UPC/EAN)',\n          type: 'TEXT',\n        },\n        {\n          id: '3b4b21b2-3c98-5380-b4a3-f9e864683b5f',\n          name: 'ratingCount',\n          xpath: \"//script[contains(text(),'ratingCount')]\",\n          singleValue: true,\n          description: 'The number of ratings',\n          type: 'TEXT',\n        },\n        {\n          id: '31b25e0b-2bb1-5e3c-91e3-b95135f28270',\n          name: 'aggregateRating',\n          xpath: \"//script[contains(text(),'aggregateRating')]\",\n          singleValue: true,\n          description: 'The stated aggregate rating normalized to be out of 5',\n          type: 'NUMBER',\n        },\n        {\n          id: '10f484cc-0cb1-5105-b42e-2405172523fc',\n          name: 'name',\n          xpath: \"//div[contains(@class,'row')]//h1\",\n          singleValue: true,\n          description: 'The product name',\n          type: 'TEXT',\n        },\n        {\n          id: '32016d5d-d934-5a6b-86fc-9ba4dd29d136',\n          name: 'secondaryImageTotal',\n          xpath: \"count(//button[contains(@class,'owl-thumb-item')][position()>1]/img/@src)\",\n          singleValue: true,\n          type: 'NUMBER',\n        },\n      ],\n      htmlExtraction: true,\n    },\n  };\n  await modules['action:product/details'](extractorInputs, { country: 'TR', domain: 'joker.com.tr', store: 'joker', zipcode: '' });\n  return extractorContext.return ? extractorContext.return(context._crawlData()) : context.data();\n};\n",
      "checkBlocked": false,
      "optional": false,
      "extractorUrl": "http://joker.com.tr"
    }
  ],
  "extractionConfigs": {
    "product/details/stores/j/joker/TR/extract": {
      "id": "product/details/stores/j/joker/TR/extract",
      "config": {
        "singleRecord": false,
        "regionsSelector": null,
        "recordSelector": null,
        "recordXPath": null,
        "fields": [
          {
            "id": "dd812847-0f10-5bfb-8b2b-036c2d759958",
            "name": "image",
            "xpath": "//*[@id=\"jMain\"]//div[@class=\"magnify\"]/img/@src",
            "singleValue": true,
            "description": "URL of the main product image",
            "type": "TEXT"
          },
          {
            "id": "39c34f83-8e77-55fa-8550-47714465578a",
            "name": "imageAlt",
            "xpath": "//div[contains(@class,'product-detail-content')]//div[contains(@class,'product-detail-content')]",
            "singleValue": true,
            "description": "Alt text of the main product image",
            "type": "TEXT"
          },
          {
            "id": "490d79c3-2364-5bc2-840d-85ba7ac85258",
            "name": "alternateImages",
            "xpath": "//*[@id=\"jMain\"]//div[contains(@class, 'owl-thumbs mobile-hidden')]/button[position()>1]/img/@src",
            "singleValue": false,
            "description": "Other product images (not in manufacturer description)",
            "type": "TEXT"
          },
          {
            "id": "9f4fc150-381e-5579-9b02-be0986d8ff5c",
            "name": "category",
            "xpath": "//*[@id=\"jMain\"]/div/nav/ol/li[contains(@class,\"active\")]",
            "singleValue": false,
            "description": "The categories (e.g. from breadcrumbs)",
            "type": "TEXT"
          },
          {
            "id": "a8d2d517-fded-5e45-a8c7-50ef5df05601",
            "name": "listPrice",
            "xpath": "//p[contains(@class,'discount-price price')]",
            "singleValue": true,
            "description": "The stated undiscounted price for the product",
            "type": "TEXT"
          },
          {
            "id": "ed9613b9-4312-5eda-b90b-e91ffe35429d",
            "name": "price",
            "xpath": "//*[@id=\"addToBasketForm\"]/div/div[3]/div[1]/div[2]/p",
            "singleValue": true,
            "description": "The offered price for the selected product variant - if a user clicks add to basket this is the price they would be charged",
            "type": "TEXT"
          },
          {
            "id": "7e4e9498-6ab8-5012-8490-5f93306d638b",
            "name": "availabilityText",
            "xpath": "boolean(//*[@id=\"addToBasketForm\"]/div/div[3]/div[3]/a[1])",
            "singleValue": true,
            "description": "Availability as described on page for the selected variant. If there is no availability but the product can be added to cart, this field should be \"In Stock\"",
            "regExp": "(.+)",
            "regExpReplace": "In Stock",
            "defaultValue": "Out of Stock",
            "type": "TEXT"
          },
          {
            "id": "d70cf327-f27b-50d5-a8fc-beced67b906c",
            "name": "description",
            "xpath": "//*[@id=\"tab01\"]/section/div[1]/p[1]",
            "singleValue": false,
            "description": "Product description supplied by website - may be concatenanted from multiple places; specifically not the manufacturer description",
            "type": "TEXT"
          },
          {
            "id": "a7ec14a4-3530-5987-8448-74f981f15cec",
            "name": "priceCurrency",
            "singleValue": true,
            "xpath": "//*[@id=\"addToBasketForm\"]/div/div[3]/div[1]/div[2]/p/span[2]",
            "regExp": "^[\\s\\S]{0,2}",
            "type": "TEXT"
          },
          {
            "id": "2d446c24-f2ac-523b-85ef-146d158f6904",
            "name": "brandText",
            "xpath": "//div[contains(@class,'product-detail-table')]//td[last()]",
            "singleValue": true,
            "description": "Product brand shown - this may actually NOT be just a brand name, e.g. \"Visit the Gillette Store\"",
            "type": "TEXT"
          },
          {
            "id": "4b17ccb0-3fd2-518a-914e-13e112ea0ef0",
            "name": "manufacturer",
            "xpath": "//div[contains(@class,'product-detail-table')]//tr[last()]//td[last()]",
            "singleValue": true,
            "description": "Product manufacturer",
            "type": "TEXT"
          },
          {
            "id": "8295f567-f653-5803-8ff9-876234334079",
            "name": "quantity",
            "xpath": "count(//*[@id=\"product-quantity\"])",
            "singleValue": true,
            "description": "Quantity as described on the page",
            "regExp": "(?:\\s?([\\d\\.]+\\s?)([bB]ar[s]?|[cC]ount|[cC]t|[fF][lL][\\.]?\\s?[oO][zZ][\\.]?|FO|[mM][lL]|[oO][zZ][\\.]?|pc|[pP]int|[pP]ops|qt|[wW]ipe[s]?).?)$|(?:\\s?([\\d\\.]+\\s?)([bB]ar[s]?|[cC]ount|[cC]|[fF][lL][\\.]?\\s?[oO][zZ][\\.]?|FO|[mM][lL]|[oO][zZ][\\.]?|pc|[pP]int|[pP]ops|qt|[wW]ipe[s]?).?\\s?[\\&\\-\\w\\s]+)$",
            "regExpReplace": "$1$2$3$4",
            "type": "TEXT"
          },
          {
            "id": "868e72ee-c11d-5025-a764-f3d508a1a792",
            "name": "weightNet",
            "xpath": "//*[@id=\"tab01\"]/section/div[1]/p[14]/font/font",
            "singleValue": true,
            "description": "Net weight as described on the page",
            "type": "TEXT"
          },
          {
            "id": "cf8cec6b-fc88-5270-aca6-d5eb60d40f4e",
            "name": "sku",
            "singleValue": true,
            "xpath": "//span[contains(@id,'sku')]",
            "description": "The store-specific product identifier",
            "type": "TEXT"
          },
          {
            "id": "60fe2efb-5db3-5d5a-876a-2fdc5c252185",
            "name": "gtin",
            "xpath": "//*[@id=\"barcode\"]/font/font",
            "singleValue": true,
            "description": "GTIN code (includes UPC/EAN)",
            "type": "TEXT"
          },
          {
            "id": "3b4b21b2-3c98-5380-b4a3-f9e864683b5f",
            "name": "ratingCount",
            "xpath": "//script[contains(text(),'ratingCount')]",
            "singleValue": true,
            "description": "The number of ratings",
            "type": "TEXT"
          },
          {
            "id": "31b25e0b-2bb1-5e3c-91e3-b95135f28270",
            "name": "aggregateRating",
            "xpath": "//script[contains(text(),'aggregateRating')]",
            "singleValue": true,
            "description": "The stated aggregate rating normalized to be out of 5",
            "type": "NUMBER"
          },
          {
            "id": "10f484cc-0cb1-5105-b42e-2405172523fc",
            "name": "name",
            "xpath": "//div[contains(@class,'row')]//h1",
            "singleValue": true,
            "description": "The product name",
            "type": "TEXT"
          },
          {
            "id": "32016d5d-d934-5a6b-86fc-9ba4dd29d136",
            "name": "secondaryImageTotal",
            "xpath": "count(//button[contains(@class,'owl-thumb-item')][position()>1]/img/@src)",
            "singleValue": true,
            "type": "NUMBER"
          }
        ],
        "htmlExtraction": true
      }
    }
  },
  "extractions": {
    "product/details/stores/j/joker/TR/extract": {
      "id": "product/details/stores/j/joker/TR/extract",
      "config": {
        "singleRecord": false,
        "regionsSelector": null,
        "recordSelector": null,
        "recordXPath": null,
        "fields": [
          {
            "id": "dd812847-0f10-5bfb-8b2b-036c2d759958",
            "name": "image",
            "xpath": "//*[@id=\"jMain\"]//div[@class=\"magnify\"]/img/@src",
            "singleValue": true,
            "description": "URL of the main product image",
            "type": "TEXT"
          },
          {
            "id": "39c34f83-8e77-55fa-8550-47714465578a",
            "name": "imageAlt",
            "xpath": "//div[contains(@class,'product-detail-content')]//div[contains(@class,'product-detail-content')]",
            "singleValue": true,
            "description": "Alt text of the main product image",
            "type": "TEXT"
          },
          {
            "id": "490d79c3-2364-5bc2-840d-85ba7ac85258",
            "name": "alternateImages",
            "xpath": "//*[@id=\"jMain\"]//div[contains(@class, 'owl-thumbs mobile-hidden')]/button[position()>1]/img/@src",
            "singleValue": false,
            "description": "Other product images (not in manufacturer description)",
            "type": "TEXT"
          },
          {
            "id": "9f4fc150-381e-5579-9b02-be0986d8ff5c",
            "name": "category",
            "xpath": "//*[@id=\"jMain\"]/div/nav/ol/li[contains(@class,\"active\")]",
            "singleValue": false,
            "description": "The categories (e.g. from breadcrumbs)",
            "type": "TEXT"
          },
          {
            "id": "a8d2d517-fded-5e45-a8c7-50ef5df05601",
            "name": "listPrice",
            "xpath": "//p[contains(@class,'discount-price price')]",
            "singleValue": true,
            "description": "The stated undiscounted price for the product",
            "type": "TEXT"
          },
          {
            "id": "ed9613b9-4312-5eda-b90b-e91ffe35429d",
            "name": "price",
            "xpath": "//*[@id=\"addToBasketForm\"]/div/div[3]/div[1]/div[2]/p",
            "singleValue": true,
            "description": "The offered price for the selected product variant - if a user clicks add to basket this is the price they would be charged",
            "type": "TEXT"
          },
          {
            "id": "7e4e9498-6ab8-5012-8490-5f93306d638b",
            "name": "availabilityText",
            "xpath": "boolean(//*[@id=\"addToBasketForm\"]/div/div[3]/div[3]/a[1])",
            "singleValue": true,
            "description": "Availability as described on page for the selected variant. If there is no availability but the product can be added to cart, this field should be \"In Stock\"",
            "regExp": "(.+)",
            "regExpReplace": "In Stock",
            "defaultValue": "Out of Stock",
            "type": "TEXT"
          },
          {
            "id": "d70cf327-f27b-50d5-a8fc-beced67b906c",
            "name": "description",
            "xpath": "//*[@id=\"tab01\"]/section/div[1]/p[1]",
            "singleValue": false,
            "description": "Product description supplied by website - may be concatenanted from multiple places; specifically not the manufacturer description",
            "type": "TEXT"
          },
          {
            "id": "a7ec14a4-3530-5987-8448-74f981f15cec",
            "name": "priceCurrency",
            "singleValue": true,
            "xpath": "//*[@id=\"addToBasketForm\"]/div/div[3]/div[1]/div[2]/p/span[2]",
            "regExp": "^[\\s\\S]{0,2}",
            "type": "TEXT"
          },
          {
            "id": "2d446c24-f2ac-523b-85ef-146d158f6904",
            "name": "brandText",
            "xpath": "//div[contains(@class,'product-detail-table')]//td[last()]",
            "singleValue": true,
            "description": "Product brand shown - this may actually NOT be just a brand name, e.g. \"Visit the Gillette Store\"",
            "type": "TEXT"
          },
          {
            "id": "4b17ccb0-3fd2-518a-914e-13e112ea0ef0",
            "name": "manufacturer",
            "xpath": "//div[contains(@class,'product-detail-table')]//tr[last()]//td[last()]",
            "singleValue": true,
            "description": "Product manufacturer",
            "type": "TEXT"
          },
          {
            "id": "8295f567-f653-5803-8ff9-876234334079",
            "name": "quantity",
            "xpath": "count(//*[@id=\"product-quantity\"])",
            "singleValue": true,
            "description": "Quantity as described on the page",
            "regExp": "(?:\\s?([\\d\\.]+\\s?)([bB]ar[s]?|[cC]ount|[cC]t|[fF][lL][\\.]?\\s?[oO][zZ][\\.]?|FO|[mM][lL]|[oO][zZ][\\.]?|pc|[pP]int|[pP]ops|qt|[wW]ipe[s]?).?)$|(?:\\s?([\\d\\.]+\\s?)([bB]ar[s]?|[cC]ount|[cC]|[fF][lL][\\.]?\\s?[oO][zZ][\\.]?|FO|[mM][lL]|[oO][zZ][\\.]?|pc|[pP]int|[pP]ops|qt|[wW]ipe[s]?).?\\s?[\\&\\-\\w\\s]+)$",
            "regExpReplace": "$1$2$3$4",
            "type": "TEXT"
          },
          {
            "id": "868e72ee-c11d-5025-a764-f3d508a1a792",
            "name": "weightNet",
            "xpath": "//*[@id=\"tab01\"]/section/div[1]/p[14]/font/font",
            "singleValue": true,
            "description": "Net weight as described on the page",
            "type": "TEXT"
          },
          {
            "id": "cf8cec6b-fc88-5270-aca6-d5eb60d40f4e",
            "name": "sku",
            "singleValue": true,
            "xpath": "//span[contains(@id,'sku')]",
            "description": "The store-specific product identifier",
            "type": "TEXT"
          },
          {
            "id": "60fe2efb-5db3-5d5a-876a-2fdc5c252185",
            "name": "gtin",
            "xpath": "//*[@id=\"barcode\"]/font/font",
            "singleValue": true,
            "description": "GTIN code (includes UPC/EAN)",
            "type": "TEXT"
          },
          {
            "id": "3b4b21b2-3c98-5380-b4a3-f9e864683b5f",
            "name": "ratingCount",
            "xpath": "//script[contains(text(),'ratingCount')]",
            "singleValue": true,
            "description": "The number of ratings",
            "type": "TEXT"
          },
          {
            "id": "31b25e0b-2bb1-5e3c-91e3-b95135f28270",
            "name": "aggregateRating",
            "xpath": "//script[contains(text(),'aggregateRating')]",
            "singleValue": true,
            "description": "The stated aggregate rating normalized to be out of 5",
            "type": "NUMBER"
          },
          {
            "id": "10f484cc-0cb1-5105-b42e-2405172523fc",
            "name": "name",
            "xpath": "//div[contains(@class,'row')]//h1",
            "singleValue": true,
            "description": "The product name",
            "type": "TEXT"
          },
          {
            "id": "32016d5d-d934-5a6b-86fc-9ba4dd29d136",
            "name": "secondaryImageTotal",
            "xpath": "count(//button[contains(@class,'owl-thumb-item')][position()>1]/img/@src)",
            "singleValue": true,
            "type": "NUMBER"
          }
        ],
        "htmlExtraction": true
      }
    }
  }
}